name: Secret Sanity

on:
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Check secrets for stray comments/spaces and hex shape
        shell: bash
        env:
          # === chiavi/endpoint (niente is_hex) ===
          ALCHEMY_API_KEY:        ${{ secrets.ALCHEMY_API_KEY }}
          ETHERSCAN_API_KEY:      ${{ secrets.ETHERSCAN_API_KEY }}
          ZEROX_API_KEY:          ${{ secrets.ZEROX_API_KEY }}
          TELEGRAM_TOKEN:         ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHATID:        ${{ secrets.TELEGRAM_CHATID }}
          RPC_URL:                ${{ secrets.RPC_URL }}
          RPC_FALLBACKS:          ${{ secrets.RPC_FALLBACKS }}
          BINANCE_API_KEY:        ${{ secrets.BINANCE_API_KEY }}
          THEGRAPH_API_KEY:       ${{ secrets.THEGRAPH_API_KEY }}

          # === address tipo 0x…40 (controllo is_hex) ===
          TREASURY_TOKEN_ADDRESS:           ${{ secrets.TREASURY_TOKEN_ADDRESS }}
          WETH_TOKEN_ADDRESS:               ${{ secrets.WETH_TOKEN_ADDRESS }}
          WETH_TOKEN_ADDRESS_ARBITRUM:      ${{ secrets.WETH_TOKEN_ADDRESS_ARBITRUM }}
          WETH_TOKEN_ADDRESS_ETHEREUM:      ${{ secrets.WETH_TOKEN_ADDRESS_ETHEREUM }}
          WETH_TOKEN_ADDRESS_LINEA:         ${{ secrets.WETH_TOKEN_ADDRESS_LINEA }}
          MOONWELL_CBETH_CTOKEN:            ${{ secrets.MOONWELL_CBETH_CTOKEN }}
          MOONWELL_USDC_CTOKEN:             ${{ secrets.MOONWELL_USDC_CTOKEN }}
          MOONWELL_WETH_CTOKEN:             ${{ secrets.MOONWELL_WETH_CTOKEN }}
          WETH_E_TOKEN_AVALANCHE:           ${{ secrets.WETH_E_TOKEN_AVALANCHE }}

          # ⚠️ NON controlliamo JSON multi-linea (es. CDP_API_KEY_FILE) per evitare falsi positivi su spazi/newline
        run: |
          fail=0
          check_basic () {
            local name="$1"; local val="${!name}"

            if [ -z "${val+x}" ]; then
              echo "::warning title=${name}::unset (secret mancante?)"
              return
            fi

            # flag commenti/spazi/newline (senza stampare il valore)
            if printf '%s' "$val" | grep -q '#'; then
              echo "::error title=${name}::contiene il carattere '#'. Probabile commento copiato: reimposta il secret senza commenti."
              fail=1
            fi
            if printf '%s' "$val" | grep -q '[[:space:]]'; then
              echo "::error title=${name}::contiene spazi o newline. Salva il secret come valore 'nudo' (nessun spazio a fine riga)."
              fail=1
            fi

            # lunghezza (diagnostica innocua)
            echo "${name}: len=${#val}"
          }

          check_hex () {
            local name="$1"; local val="${!name}"
            [ -z "${val+x}" ] && return
            if ! printf '%s' "$val" | grep -Eq '^0x[0-9a-fA-F]{40}$'; then
              echo "::error title=${name}::non sembra un address EVM valido (atteso 0x + 40 hex)."
              fail=1
            else
              echo "${name}: is_hex=true"
            fi
          }

          # gruppo 1: controlli base
          for s in ALCHEMY_API_KEY ETHERSCAN_API_KEY ZEROX_API_KEY TELEGRAM_TOKEN TELEGRAM_CHATID RPC_URL RPC_FALLBACKS BINANCE_API_KEY THEGRAPH_API_KEY; do
            check_basic "$s"
          done

          # gruppo 2: address EVM
          for s in TREASURY_TOKEN_ADDRESS WETH_TOKEN_ADDRESS WETH_TOKEN_ADDRESS_ARBITRUM WETH_TOKEN_ADDRESS_ETHEREUM WETH_TOKEN_ADDRESS_LINEA MOONWELL_CBETH_CTOKEN MOONWELL_USDC_CTOKEN MOONWELL_WETH_CTOKEN WETH_E_TOKEN_AVALANCHE; do
            check_basic "$s"
            check_hex "$s"
          done

          exit $fail
